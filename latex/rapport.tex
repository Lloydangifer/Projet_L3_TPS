\documentclass[12pt]{report}


\usepackage[latin1]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{lipsum}
\usepackage{aeguill} % Police moins floue
\usepackage{graphicx} % Insérer des images 

\usepackage{titling} % image on title page

\usepackage{xcolor} % DES JOLIES COULEURS

\usepackage{listings} % pour écrire du code avec de la coloration syntaxique
%%configuration de listings
\lstset{
language=python,
basicstyle=\ttfamily\small, %
identifierstyle=\color{black}, %
keywordstyle=\color{blue}, %
stringstyle=\color{purple}, %
commentstyle=\it\color{green}, %
columns=flexible, %
tabsize=2, %
extendedchars=true, %
showspaces=false, %
showstringspaces=false, %
numbers=left, %
numberstyle=\tiny, %
breaklines=true, %
breakautoindent=true, %
captionpos=b
}


\usepackage{hyperref} % Créer des liens et des signets, utile pour la table des matières
\hypersetup{	
	colorlinks=true, %colorise les liens 
	breaklinks=true, %permet le retour à la ligne dans les liens trop longs 
	urlcolor= blue, %couleur des hyperliens 
	linkcolor= black,	%couleur des liens internes 
	citecolor=black,	%couleur des références 
	pdftitle={Rapport de projet}, %informations apparaissant dans 
	pdfauthor={Virgil Manrique, Quentin Guillien}, %les informations du document 
	pdfsubject={TPS avec le Shine Engine}	%sous Acrobat. 
} 

\usepackage[margin=3cm]{geometry}

\usepackage{titlesec}
\titleformat{\chapter}[hang]{\bf\huge}{\thechapter}{2pc}{}
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

%Glossaire
\usepackage{glossaries}
\makeglossaries
\newacronym{TPS}{TPS}{Third-Person Shooter}

\begin{document}


\begin{titlepage}
	\centering
	\includegraphics[width=4.5cm]{logo-ufc.jpg}\par\vspace{2mm}
	{\scshape\large Université de Franche-Comté \par}
	\vspace{1cm}
	{\scshape\Large Rapport de projet tuteuré\par
	Licence informatique 3\up{ème} Année\par}
	\vspace{1.5cm}
	{\huge\bfseries Création d'un Third-Person Shooter avec le \textsc{Shine Engine}\par}
	\vspace{9mm}
	\includegraphics[width=6cm]{logo_shine.png}\par\vspace{15mm}
	{\Large Virgil \textsc{Manrique} \hspace{5mm} Quentin \textsc{Guillien}\par}
	\vfill
	Encadrant : \par
	Sylvain \textsc{Grosdemouge}

	\vfill

% Bottom of the page
	{\large Année 2015-2016\par}
\end{titlepage}


\setlength{\parskip}{2.5mm}

\section*{\centering Remerciements}
\phantomsection
%\addcontentsline
\vspace{1cm}

Ce projet tuteuré n'aurait pu être réalisé sans l'aide de plusieurs personnes que nous tenons à remercier.
\vspace{4mm}

Tout d'abord, nous remercions notre encadrant M. Sylvain \textsc{Grosdemouge} pour nous avoir guidé et prodigué ses conseils durant la réalisation de ce projet.

Ensuite, nous voulons remercier M. Bastien \bsc{Schatt}, pour nous avoir aidés lors de notre apprentissage de l'utilisation du Shine Engine ainsi que pour sa réactivité lorsque nous avons rencontré des problèmes.

Nous voulons également remercier M. Nicolas \bsc{Diot}, pour son assistance apportée par rapport au fonctionnement de l'éditeur de niveaux du Shine Engine et des ressources graphiques.

Nous tenons enfin à remercier toutes les personnes qui nous ont aidés de près ou de loin.


% Table des matières, sans numérotation
\renewcommand{\thepage}{}
\tableofcontents
\newpage
\renewcommand{\thepage}{\arabic{page}}


% Introduction
\chapter{Cadre du projet}
Dans le cadre de notre 3\up{ème} année de licence informatique à l'université de Franche-Comté, il nous a été demandé de réaliser un projet dans le cadre du module projet tuteuré. La durée du projet s'étendait d'Octobre à Mars.

Parmis les sujets proposés, l'un d'entre eux a particulièrement retenu notre attention. Il s'agissait du développement d'un Third-Person Shooter en utilisant un moteur de jeu : le \texttt{Shine Engine} développé par M. Sylvain \textsc{Grosdemouge}.

Nous avons pu nous voir attribuer ce sujet l'ayant placé en première position dans notre liste de choix.

Pour comprendre l'intérêt que nous portions à ce sujet, il faut nous pencher sur les différents éléments qui le constituent, à savoir les Third-Person Shooter, les moteurs de jeu, et le \texttt{Shine Engine}.

\section{Les Third-Person Shooter}

Un TPS (Third-Person Shooter ou jeu de tir à la troisième personne en français) est un sous-genre des jeux de tir et donc des jeux d'action. Les jeux de tir mettent souvent la rapidité et la réactivité du joueur à l'épreuve. L'objectif de ce genre de jeu est de vaincre ses ennemis en utilisant une arme de tir. La particularité des \texttt{TPS}\footnote{\textbf{T}hird-\textbf{P}erson \textbf{S}hooter} est que le joueur voit son personnage de manière externe contrairement aux \texttt{FPS}\footnote{\textbf{F}irst-\textbf{P}erson \textbf{S}hooter : Jeu de tir à la 1\up{ère} personne} où le joueur voit à travers les yeux de son personnage.

\begin{figure}[!h] %on ouvre l'environnement figure
\centering
\includegraphics[width=7cm]{re4_1.jpg} %ou image.png, .jpeg etc.
\caption{Un exemple de \texttt{TPS} : Resident Evil 4} %la légende
\label{re4} %l'étiquette pour faire référence à cette image
\end{figure} %on ferme l'environnement figure

\section{Les moteurs de jeu}

``Un moteur de jeu est un ensemble de composants logiciels qui effectuent des calculs de géométrie et de physique utilisés dans les jeux vidéo. L'ensemble forme un simulateur en temps réel souple qui reproduit les caractéristiques des mondes imaginaires dans lesquels se déroulent les jeux. Le but visé par un moteur de jeu est de permettre à une équipe de développement de se concentrer sur le contenu et le déroulement du jeu plutôt que la résolution de problèmes informatiques.''
\begin{flushright}
-- \href{https://fr.wikipedia.org/wiki/Moteur_de_jeu}{\textsl{Définition Wikipédia}}
\end{flushright}

\section{Le \texttt{Shine Engine}}

Le \texttt{Shine Engine} est un moteur de jeu créé par notre encadrant, Monsieur Sylvain \textsc{Grosdemouge}. Monsieur \textsc{Grosdemouge} a commencé le développement du \texttt{Shine Engine} en 2005 et en 2012 est sorti \textsc{R.A.W.}(Realm Of Ancient War), premier jeu développé en utilisant le \texttt{Shine Engine}. Ce moteur de jeu est développé en C++ et permet de faire du développement multi-plateforme. Il permet aussi de gérer facilement la 3D ce qui permet de s'affranchir de beaucoup de limites pour le développement d'un jeu. De plus le moteur fonctionne avec un éditeur de niveau, le Shine Game Editor, qui facilement grandement la création de niveaux.

\section{Le Projet}

Les trois éléments cités précédemment rendaient pour nous le projet attrayant: les TPS sont un genre de jeu au concept simple mais distrayant; utiliser un moteur de jeu permet de se concentrer sur les mécaniques de jeu, qui sont pour nous la partie la plus intéressante du développement d'un jeu; et enfin, le \texttt{Shine Engine}, un moteur qui a fait ses preuves, qui est efficace et qui nous permet de développer en C++, le langage que nous préférons.

\begin{figure}[!h] %on ouvre l'environnement figure
\centering
\includegraphics[width=6cm]{raw-03.jpg} %ou image.png, .jpeg etc.
\caption{ \textsc{Realm Of Ancient War}} %la légende
\label{re4} %l'étiquette pour faire référence à cette image
\end{figure} %on ferme l'environnement figure

\chapter{Préparation}

\section{Installation des outils}
\hypertarget{installation}{}

\label{labelInstal}Avant de commencer à coder, il a d'abord fallu installer plusieurs outils logiciels.

\begin{flushright}
\textit{Tous les outils mentionnés ont été utilisés, dans notre cas, sur Windows uniquement.}
\end{flushright}

\subsection{Les indispensables}
Les trois logiciels indispensables sont le \texttt{Shine SDK}\footnote{SDK = Software Development Kit (trousse de développement logiciel en Français)}, le \texttt{Shine Editor}\footnote{Editeur graphique de Shine permettant d'ajouter facilement des éléments visuels dans un jeu} et \texttt{Microsoft Visual Studio 2010}.

Le \texttt{Shine Editor} et le \texttt{SDK} ne requérant pas d'installation, n'ont pas posé de problèmes dans un premier temps. En revanche, il n'a pas été facile de retrouver la version 2010 de \texttt{Visual Studio}, car aujourd'hui, Microsoft ne propose que la version \textsl{Community} de leur logiciel.
\texttt{Visual Studio} est un \texttt{IDE}\footnote{IDE = Integrated Development Environment (Environnement de Développement en Français)}. Il en existe d'autres, mais le \texttt{Shine Engine} a été développé et prévu pour être intégré à \texttt{Visual Studio}.

Même après avoir installé les outils \texttt{Shine}, il ne peuvent pas encore être exécutés indépendamment. En effet, ils requièrent le \texttt{DirectX SDK} mais aussi \texttt{Microsoft .NET Framework} (version 4.0 ou supérieur).

\subsection{Pour plus de confort}

\textit{Bien qu'ils ne soient pas réellement indispensables, les outils suivants nous été extrêmement utiles.}

Nous avons utilisé \texttt{Git}, plus précisément \texttt{Github}, l'application graphique de Git pour Windows. \href{https://fr.wikipedia.org/wiki/GitHub}{\texttt{GitHub}} est un service web d'hébergement et de gestion de développement de logiciels utilisant Git, le logiciel de gestion de versions décentralisé.

Nous avons également utilisé \texttt{Trello}, un outil de gestion de projet en ligne permettant d'assigner facilement des tâches à des utilisateurs. 

\textsc{gimp}\footnote{GNU Image Manipulation Program} est un outil d'édition et de retouche d'image. \textsc{gimp} a été utile pour créer des \texttt{sprite}\footnote{Elément graphique qui peut se déplacer sur l'écran. Dans notre cas, cet élément était une simple image en deux dimensions} simples.

En complément de \textsc{gimp} nous avons utilisé \texttt{XnView}, qui nous a permis de vérifier le formats de certains fichiers, et de convertir au bon format si besoin.

Enfin, nous avons utilisé \LaTeX\ pour la rédaction de ce rapport.

\section{Formation au \textsc{Shine Engine}}

Pour apprendre à utiliser le moteur, nous avons assisté aux formations au \texttt{Shine Engine} dispensées par \texttt{Shine Research} au Cub' à Essais, à l'incubateur d'entreprises innovantes de Franche-Comté, tous les jeudis à 17h pendant 10 semaines. Ces formations nous ont été utiles pour apprendre les bases du fonctionnement du \texttt{Shine Engine} et ainsi pouvoir maitriser par nous-même des fonctionnalités plus avancées.

\chapter{Réalisation}

Dans ce chapitre nous allons expliquer chaque élément constituant le jeu, que ce soit le joueur ou les ennemis, les armes et leurs munitions ou bien la gestion des collisions.

\section{Jeu ou Plugin ?}

Pour réaliser ce projet, notre encadrant nous a demandé de développer le jeu non pas de manière classique mais en utilisant la fonctionnalité de \texttt{plugin} du \texttt{Shine Engine}. Nous avons donc développé les mécaniques de jeu en gardant en tête que la fonction de \texttt{plugin} permettait d'utiliser le plugin simplement en l'activant lors de la création d'un niveau, par exemple en utilisant l'éditeur de Shine, ce qui nous a poussé à développer de manière générique et non pas en fonction du niveau.

Monsieur \textsc{Grosdemouge} nous a donné des \texttt{sprite} simples pour faire un niveau de test mais nous avons par la suite réalisé d'autres \texttt{sprite} pour faire d'autres niveaux afin de vérifier le bon fonctionnement du \texttt{plugin}.

\section{Éléments du plugin}
\subsection{Les personnages}

Le \texttt{plugin} doit pouvoir gérer deux types de personnages: le personnage du joueur, contrôlé par ce dernier et le ou les personnages ennemis, qui disposent de leur propre IA\footnote{\textbf{I}ntelligence \textbf{A}rtificielle}.
Pour cela nous avons crée une classe générique \texttt{Character} de laquelle héritent les classes \texttt{Player} et \texttt{Enemy}.

Cette classe a pour grande utilité de permettre un traitement générique ainsi que la possibilité d'une modification générique. Ainsi, lorsque nous avons voulu implémenter la gestion de la 3D, il nous a suffit d'ajouter un attribut à cette classe pour stocker le modèle 3D. Le joueur et les ennemis ont donc été dotés de cet attribut.

Un personnage peut posséder une arme et tirer avec celle-ci, nous détaillerons cela plus en détail dans la partie consacrée à la classe associée aux \hyperlink{armes}{\textbf{armes}}, à savoir la classe \texttt{Gun}.
Un personnage peut aussi mourir s'il entre en contact avec un projectile, exception faite des projectiles qu'il a tiré lui-même.

\subsection{Le Joueur}

Pour bien différencier le joueur des ennemis, et puisque les deux n'ont pas le même fonctionnement, nous avons crée une classe \texttt{Player} qui hérite de la classe \texttt{Character}, la rendant donc similaire à la classe \texttt{Enemy} mais dénué d'IA et contrôlé à l'aide des touches du clavier.

Le joueur peut ainsi faire avancer son avatar avec la flèche haut ou la touche Z. Les touches flèche gauche (ou la touche Q) et flèche droite (ou la touche D) permettent d'effectuer une rotation respectivement vers la gauche ou la droite. Le joueur peut aussi reculer en utilisant la touche flèche bas (ou la touche S) mais se déplace dans ce cas à la moitié de sa vitesse.

Initialement, notre encadrant ne nous avait pas demandé de permettre au joueur de reculer mais nous avons rajouté cette fonctionnalité pour un meilleur confort de jeu après avoir fait quelques test lors de l'implémentation des projectiles et de la possibilité pour l'avatar de mourir\footnote{\textsl{Il est difficile d'esquiver les projectile si on ne peut pas revenir rapidement sur ses pas}}.

\subsection{Les Ennemis}

La classe \texttt{Enemy} permet de représenter un ennemi auquel le joueur peut-être confronté. Le \texttt{plugin} gère une liste d'ennemis pour représenter tous les ennemis d'un niveau. La classe \texttt{Enemy} héritant de la classe \texttt{Character}, un \texttt{Enemy} est sensiblement identique au joueur mais à un fonctionnement différent : il est contrôlé par une IA.
 
L'IA ne fut pas simple à mettre au point bien qu'elle ait elle-même un fonctionnement simple : si l'ennemi ne voit pas le joueur, il reste sur place, si il le voit, il se déplace vers lui tout en tirant. L'IA est basée sur un automate à deux états, l'état \texttt{attaque} et l'état \texttt{repos}. L'état \texttt{repos} est son état par défaut et il passe en état \texttt{attaque} lorsqu'il voit le joueur.

L'ennemi possède un attribut \texttt{Target} qui représente la dernière position connue du joueur. A chaque \texttt{update} du jeu\footnote{Pour chaque image rendu du jeu, on effectue une \texttt{update}, c'est-à-dire qu'on met à jour tous les éléments qui composent le jeu (leur position, leur direction, leur état...)}, le gestionaire de collisions va vérifier si l'ennemi a une ligne de vue directe sur le joueur. Si c'est le cas, il met à jour l'attribut \texttt{Target} de l'ennemi. Ce faisant, l'ennemi va passer en état \texttt{attaque} s'il ne l'est pas déjà et va se rendre jusqu'à la position cible tout en tirant en direction de celle-ci. Si, en cours de chemin, il perd sa ligne de vue directe avec le joueur, il se rendra tout de même à sa dernière position connue, ce qui peut lui permettre de voir à nouveau le joueur. Nous avons doté les ennemis d'une vision à 360 degrés pour pouvoir repérer le joueur.

\subsection{Les Armes}
\hypertarget{armes}{}

Déjà évoquée plus haut, la classe \texttt{Gun} est la classe représentant les armes dans le \texttt{plugin}. Une arme est détenue par un personnage et possède plusieurs attributs notables.

Elle dispose d'un \textsl{nom}; d'un \textsl{chargeur} contenant des munitions (6 par défaut); une \textsl{puissance}, qui correspond à la vitesse de déplacement donnée aux balles tirées par l'arme; ainsi qu'une \textsl{cadence de tir} et son \textsl{temps de rechargement} associé. Le nom n'est actuellement pas utilisé mais pourrait servir pour d'éventuelles améliorations futures. Sa cadence de tir permet de s'assurer que le joueur ou les ennemis peuvent tirer plus ou moins vite en fonction de l'arme qu'ils possèdent. Lors du lancement du \texttt{plugin}, l'arme va créer ses munitions de départ et les stocker dans son chargeur, prêtes à être utilisées.

Une arme dispose d'une fonction \texttt{Shoot}, utilisée lors de l'appel à la fonction du même nom du personnage qui possède l'arme, et qui renvoie une munition, prête à se déplacer dans le niveau. Lors de l'appel à cet fonction, la munition ainsi préparée sera alors placée dans la liste de munitions actuellement en mouvement dans le niveau et retirée du chargeur de l'arme, empêchant sa réutilisation avant qu'elle n'ait rencontré un obstacle.

\subsection{Les Munitions}

La classe \texttt{Ammo} permet de représenter les munitions. Ces munitions possèdent divers attributs: une \textsl{position}, correspondant à leur position dans le niveau; une \textsl{direction}, correspondant au sens dans lequel elles se déplacent; une \textsl{vitesse}, qui correspond à leur vitesse de déplacement; un \textsl{sprite}, si le niveau est en 2D; un \textsl{modèle}, si le niveau est en 3D; un booléen \textsl{Moving} qui permet de savoir si elle sont en cours de déplacement ou pas; une \textsl{origine}, qui désigne quel personnage a tiré la munition; et un booléen qui indique si la munition est en \textsl{3D} ou pas.

La position et la direction de la munition sont données à celle-ci lorsqu'elle est tirée par le joueur, ladite munition apparait au bout du \texttt{sprite} du joueur et se dirige dans la direction où il regarde au moment où il a tiré, puis se déplace normalement, indépendamment du joueur. La vitesse est donnée par l'arme au moment du tir. Le booléen \texttt{Moving} permet de savoir si la munition a rencontré un obstacle et donc si elle peut être remise dans le chargeur. L'origine de la munition est le personnage qui a tiré celle-ci, cela permet au personnage de ne pas se faire tuer par son propre projectile.

\subsection{La Caméra}

La classe \texttt{Camera} est la classe permettant de gérer la caméra du jeu et donc la vue que peut avoir le joueur sur le niveau.

Cette classe fut plutôt simple à faire grâce au \texttt{Shine Engine} qui dispose déjà d'une classe permettant de gérer une caméra. Notre caméra se contente d'encapsuler celle du \texttt{Shine Engine} en créant toutefois quelques fonctions qui permettent un positionnement simple de ladite caméra pour correspondre à l'utilité dont peut en faire un TPS.

La caméra a 3 modes: un mode \textsl{vue de dessus}, qui suit le joueur quand il se déplace tout en permettant d'avoir une bonne vision de ce qui se trouve autour de lui, pratique pour les niveaux en 2D; un \textsl{mode de vue TPS}, qui se place derrière le joueur; et un \textsl{mode de vue haute}, qui est proche de la vue du dessus mais dans lequel le joueur reste immobile et c'est le monde qui défile par rapport à lui. On peut passer d'un mode à l'autre grâce à la touche C. Il y a aussi possibilité d'augmenter ou de diminuer le champs de vision\footnote{En anglais : \textbf{FOV} : \textbf{F}ield \textbf{O}f \textbf{V}iew} lorsqu'on est en mode caméra TPS avec les touches + et - .

\subsection{Le Gestionnaire de collisions}

Le gestionnaire de collisions est représenté grâce à la classe \texttt{CollisionsManager}. C'est cette classe qui va gérer toutes les collisions du \texttt{plugin}, que ce soit les personnages et les munitions, les munitions et les murs ou bien le champs de vision de ennemis.

La classe possède deux attributs: une liste de \texttt{CollisionShape} et le nombre de \texttt{CollisionShape} contenus dans cette liste. Une explication des \texttt{CollisionsShape} et de la gestion des collisions dans le \texttt{plugin} est donnée dans la \hyperlink{gest_coll}{\textbf{prochaine partie}}, consacrée à la gestion des collisions.

\section{Mécaniques de jeu}

Dans cette partie nous allons expliquer le fonctionnement de la gestion des collisions dans le plugin ainsi que le fonctionnement des mécaniques de jeu du plugin.

\subsection{Gestion des collisions}

La partie de gestion des collisions nous fut grandement simplifiée grâce au Shine Engine et notamment grâce à 3 fonctionnalités de celui-ci:

-Les CollisionShape: il s'agit de sortes de segments qui servent dans le moteur notamment pour faire office de murs physiques. Ils peuvent également être placés directement depuis l'éditeur, ce qui en fait un outil très pratique pour les collisions avec le décor.

-Le Character Controller: il s'agit d'une classe qui intègre nativement les collisions entre elle et les CollisionShape ainsi qu'entre les différentes instances de la classe, empêchant ainsi un Character Controller de passer à travers un autre Character Controller ou à travers un CollisionShape.

-La fonction Intersect pour les entités 2D: Il s'agit d'une fonction qui permet de savoir si deux entités 2D, basiquement des sprites, se croisent.

Grâce à ces 3 éléments, peu de travail sur les collisions restaient à faire. Nous avons doté la classe Character d'un attribut de type Character Controller et à partir de la, aucun personnage ne pouvait passer à travers un mur, mur représenté par un CollisionShape, ou à travers un autre personnage. Pour gérer la collision entre les munitions se déplaçant dans le monde et un personnage, la fonction Intersect est utilisée pour voir si les deux sprites se touchent ou se croisent.

Il nous restait donc à gérer les collisions entre les munitions et les CollisionShape ainsi que les lignes de vue des ennemis.

De ce fait pour gérer ces collisions le gestionnaire de collisions procède ainsi: 

-Pour les munitions et les CollisionShape, il vérifie si il y a intersection entre le CollisionShape et la trajectoire de la balle entre sa position actuelle et sa position après déplacement.

-Pour les lignes de vue entre les ennemis et le joueur, pour chaque ennemi, le gestionnaire vérifie si il y a un CollisionShape (un mur) entre le joueur et l'ennemi. Si ce n'est pas le cas alors l'ennemi à une ligne de vue directe sur le joueur et peut donc passer en état d'attaque./*TODO mettre une note de bas de page indiquant "pour plus de détails concernant le comportement des ennemis, reportez-vous à la section correspondante" avec lien vers ladite section et numéro de page de ladite section*/

Pour les collisions en 3D, et par souci de simplicité pour le développement du projet, le gestionnaire va utiliser les sprites 2D associés à chaque éléments. Pour comprendre comment il peut faire cela, intéressons-nous à la prochaine partie consacrée au fonctionnement du plugin.

\subsection{Fonctionnement du plugin}

Maintenant que nous avons vus les divers éléments constituant le plugin ainsi que la gestion des collisions, nous pouvons nous intéresser au fonctionnement du plugin.

Le plugin fonctionne en deux temps. Tout d'abord lors de l'appel à la fonction OnPlayStart du Shine Engine, puis lors de l'appel à la fonction OnPostUpdate du moteur de jeu. De plus le plugin est conçu pour fonctionner avec des niveaux en 2D ou bien en 3D.

La fonction OnPlayStart est appelée lorsque un niveau est débuté. Dans l'éditeur cela correspond aussi à l'appui sur le bouton Play, qui sert à tester le niveau crée avec l'aide de l'éditeur.

Lors de l'appel à la fonction OnPlayStart, le plugin va initialiser tout ce qu'il peut en fonction du niveau, il va donc initialiser le joueur en fonction de la position du sprite ou du modèle de celui-ci, en sachant qu'il faut respecter une convention de nommage propre du nom donné au joueur dans l'éditeur pour que le plugin puisse le trouver. Puis le plugin va créer et initialiser autant d'ennemis qu'il trouve de sprites ou de modèles respectant la convention de nommage. Il est à noter que 
si le plugin trouve des modèles 3D, il va charger des sprites 2D depuis la bibliothèque et créer les entités 2D associées afin de pouvoir gérer les collisions. Ce fonctionnement pourrait poser problème pour un vrai jeu 3D mais nous avons conçu le plugin comme cela pour le projet pour un souci de simplicité.

La fonction OnPostUpdate est appelée par le moteur de jeu après sa propre update. C'est dans cette fonction que le plugin se met à jour.

A chaque appel à la fonction OnPostUpdate, le plugin se met à jour. Il va d'abord vérifier l'appui sur les différents inputs du joueur pour faire réagir l'avatar de celui-ci ou la caméra en conséquence. Il va ensuite faire appel au gestionnaire de collisions pour s'occuper des lignes de vue de chaque ennemi ainsi que les éventuels tirs de ceux-ci; puis il va, toujours en faisant appel au gestionnaire de collisions, vérifier les collisions des munitions avec les différents éléments de l'environnement, personnages inclus; enfin il appelle succinctement les différentes fonctions update des différents éléments du niveau (joueur, ennemis et munitions).

\hypertarget{gest_coll}{}
\section{Problèmes rencontrés}

\subsection{Problèmes logiciels}

Nous l'avons mentionné dans la partie \hyperlink{installation}{\textbf{Installation}} (page~\pageref{labelInstal}), trouver la version complète de \texttt{Microsoft Visual Studio 2010} n'a pas été tâche facile.

Cependant, cela n'a pas été le plus important des problèmes logiciel que nous avons eu. En effet, il nous est arrivé par exemple de ne plus pouvoir lancer l'éditeur de \texttt{Shine} alors qu'il marchait auparavant, sans savoir pourquoi. Réinstaller l'éditeur, ou installer une version plus récente résolvait en général les problèmes rencontrés. Il nous est également arrivé de simplement ne pas du tout pouvoir faire fonctionner le \texttt{Shine Editor} sur un PC (la seule option était ici d'utiliser un autre PC).

\subsection{Problèmes de code}

Le problème majeur qui nous a couté le plus de temps est celui-ci : 

\begin{lstlisting}
	///	@todo comment
\end{lstlisting}

Cette ligne, combinée à l'inexistence de documentation, nous a souvent laissé dans le flou quand à la manière de procéder pour effectuer des tâches parfois assez simples.
La seule chose dont on pouvait s'aider était les fichiers d'entête dans les dossier du \texttt{Shine SDK} : en lisant les définitions des méthodes et les noms des paramètres, on pouvait au mieux \textsl{deviner} la façon d'utiliser ces méthodes.

Bien sûr, quand on ne pouvait plus avancer, nous avons pris contact avec l'équipe de \texttt{Shine}. Cependant, la réponse n'étant évidemment pas immédiate, il nous est arrivé de rester bloquer des après-midis entiers à essayer de faire marcher un bout de code.



\chapter{Bilan}

\subsection{Optimisations Possibles}

Ennemis avec cône de vision
Améliorations d'armes liés au nom de l'arme
Gestion des collisions 3D avec hitbox 3D tout ça.
Minimap comme demandé par Grosdemouge.

\printglossaries

\end{document}