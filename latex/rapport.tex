\documentclass[12pt]{report}


\usepackage[latin1]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{lipsum}
\usepackage{aeguill} % Police moins floue
\usepackage{graphicx} % Insérer des images 

\usepackage{titling} % image on title page

\usepackage{xcolor} % DES JOLIES COULEURS

\usepackage{listings} % pour écrire du code avec de la coloration syntaxique
%%configuration de listings
\lstset{
language=python,
basicstyle=\ttfamily\small, %
identifierstyle=\color{black}, %
keywordstyle=\color{blue}, %
stringstyle=\color{purple}, %
commentstyle=\it\color{green}, %
columns=flexible, %
tabsize=2, %
extendedchars=true, %
showspaces=false, %
showstringspaces=false, %
numbers=left, %
numberstyle=\tiny, %
breaklines=true, %
breakautoindent=true, %
captionpos=b
}


\usepackage{hyperref} % Créer des liens et des signets, utile pour la table des matières
\hypersetup{	
	colorlinks=true, %colorise les liens 
	breaklinks=true, %permet le retour à la ligne dans les liens trop longs 
	urlcolor= blue, %couleur des hyperliens 
	linkcolor= black,	%couleur des liens internes 
	citecolor=black,	%couleur des références 
	pdftitle={Rapport de projet}, %informations apparaissant dans 
	pdfauthor={Virgil Manrique, Quentin Guillien}, %les informations du document 
	pdfsubject={TPS avec le Shine Engine}	%sous Acrobat. 
} 

\usepackage[margin=3cm]{geometry}

\usepackage{titlesec}
\titleformat{\chapter}[hang]{\bf\huge}{\thechapter}{2pc}{}
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

%Glossaire
\usepackage{glossaries}
\makeglossaries
\newacronym{TPS}{TPS}{Third-Person Shooter}

\begin{document}


\begin{titlepage}
	\centering
	\includegraphics[width=4.5cm]{logo-ufc.jpg}\par\vspace{2mm}
	{\scshape\large Université de Franche-Comté \par}
	\vspace{1cm}
	{\scshape\Large Rapport de projet tuteuré\par
	Licence informatique 3\up{ème} Année\par}
	\vspace{1.5cm}
	{\huge\bfseries Création d'un Third-Person Shooter avec le \textsc{Shine Engine}\par}
	\vspace{9mm}
	\includegraphics[width=6cm]{logo_shine.png}\par\vspace{15mm}
	{\Large Virgil \textsc{Manrique} \hspace{5mm} Quentin \textsc{Guillien}\par}
	\vfill
	Encadrant : \par
	Sylvain \textsc{Grosdemouge}

	\vfill

% Bottom of the page
	{\large Année 2015-2016\par}
\end{titlepage}


\setlength{\parskip}{2.5mm}

\section*{\centering Remerciements}
\phantomsection
%\addcontentsline
\vspace{1cm}

Ce projet tuteuré n'aurait pu être réalisé sans l'aide de plusieurs personnes que nous tenons à remercier.
\vspace{4mm}

Tout d'abord, nous remercions notre encadrant M. Sylvain \textsc{Grosdemouge} pour nous avoir guidé et prodigué ses conseils durant la réalisation de ce projet.

Ensuite, nous voulons remercier M. Bastien \bsc{Schatt}, pour nous avoir aidés lors de notre apprentissage de l'utilisation du Shine Engine ainsi que pour sa réactivité lorsque nous avons rencontré des problèmes.

Nous voulons également remercier M. Nicolas \bsc{Diot}, pour son assistance apportée par rapport au fonctionnement de l'éditeur de niveaux du Shine Engine et des ressources graphiques.

Nous tenons enfin à remercier toutes les personnes qui nous ont aidés de près ou de loin.


% Table des matières, sans numérotation
\renewcommand{\thepage}{}
\tableofcontents
\newpage
\renewcommand{\thepage}{\arabic{page}}


% Introduction
\chapter{Cadre du projet}
Dans le cadre de notre 3\up{ème} année de licence informatique à l'université de Franche-Comté, il nous a été demandé de réaliser un projet dans le cadre du module projet tuteuré. La durée du projet s'étendait d'Octobre à Mars.

Parmis les sujets proposés, l'un d'entre eux a particulièrement retenu notre attention. Il s'agissait du développement d'un Third-Person Shooter en utilisant un moteur de jeu : le \texttt{Shine Engine} développé par M. Sylvain \textsc{Grosdemouge}.

Nous avons pu nous voir attribuer ce sujet l'ayant placé en première position dans notre liste de choix.

Pour comprendre l'intérêt que nous portions à ce sujet, il faut nous pencher sur les différents éléments qui le constituent, à savoir les Third-Person Shooter, les moteurs de jeu, et le \texttt{Shine Engine}.

\section{Les Third-Person Shooter}

Un TPS (Third-Person Shooter ou jeu de tir à la troisième personne en français) est un sous-genre des jeux de tir et donc des jeux d'action. Les jeux de tir mettent souvent la rapidité et la réactivité du joueur à l'épreuve. L'objectif de ce genre de jeu est de vaincre ses ennemis en utilisant une arme de tir. La particularité des \texttt{TPS}\footnote{\textbf{T}hird-\textbf{P}erson \textbf{S}hooter} est que le joueur voit son personnage de manière externe contrairement aux \texttt{FPS}\footnote{\textbf{F}irst-\textbf{P}erson \textbf{S}hooter : Jeu de tir à la 1\up{ère} personne} où le joueur voit à travers les yeux de son personnage. (Voir Figure~\ref{fig:re4} page~\pageref{fig:re4})

\pagebreak
\section{Les moteurs de jeu}

``Un moteur de jeu est un ensemble de composants logiciels qui effectuent des calculs de géométrie et de physique utilisés dans les jeux vidéo. L'ensemble forme un simulateur en temps réel souple qui reproduit les caractéristiques des mondes imaginaires dans lesquels se déroulent les jeux. Le but visé par un moteur de jeu est de permettre à une équipe de développement de se concentrer sur le contenu et le déroulement du jeu plutôt que la résolution de problèmes informatiques.''
\begin{flushright}
-- \href{https://fr.wikipedia.org/wiki/Moteur_de_jeu}{\textsl{Définition Wikipédia}}
\end{flushright}

\section{Le \textsc{Shine Engine}}

Le \texttt{Shine Engine} est un moteur de jeu créé par notre encadrant, Monsieur Sylvain \textsc{Grosdemouge}. Monsieur \textsc{Grosdemouge} a commencé le développement du \texttt{Shine Engine} en 2005 et en 2012 est sorti \textsc{R.A.W.}(Realm Of Ancient War), premier jeu développé en utilisant le \texttt{Shine Engine}. Ce moteur de jeu est développé en C++ et permet de faire du développement multi-plateforme. Il permet aussi de gérer facilement la 3D ce qui permet de s'affranchir de beaucoup de limites pour le développement d'un jeu. De plus le moteur fonctionne avec un éditeur de niveau, le Shine Game Editor, qui facilement grandement la création de niveaux. (Voir Figure~\ref{fig:raw} page~\pageref{fig:raw})

\section{Le Projet}

Les trois éléments cités précédemment rendaient pour nous le projet attrayant: les TPS sont un genre de jeu au concept simple mais distrayant; utiliser un moteur de jeu permet de se concentrer sur les mécaniques de jeu, qui sont pour nous la partie la plus intéressante du développement d'un jeu; et enfin, le \texttt{Shine Engine}, un moteur qui a fait ses preuves, qui est efficace et qui nous permet de développer en C++, le langage que nous préférons.

\begin{figure}[!h] %on ouvre l'environnement figure
\centering
\includegraphics[width=16cm]{re4_1.jpg} %ou image.png, .jpeg etc.
\caption{Un exemple de \texttt{TPS} : Resident Evil 4} %la légende
\label{fig:re4} %l'étiquette pour faire référence à cette image
\end{figure} %on ferme l'environnement figure

\begin{figure}[!h] %on ouvre l'environnement figure
\centering
\includegraphics[width=16cm]{raw-03.jpg} %ou image.png, .jpeg etc.
\caption{ \textsc{Realm Of Ancient War}, un jeu réalisé avec le \texttt{Shine Engine}} %la légende
\label{fig:raw} %l'étiquette pour faire référence à cette image
\end{figure} %on ferme l'environnement figure

\chapter{Préparation}

\section{Installation des outils}
\hypertarget{installation}{}

\label{labelInstal}Avant de commencer à coder, il a d'abord fallu installer plusieurs outils logiciels.

\begin{flushright}
\textit{Tous les outils mentionnés ont été utilisés, dans notre cas, sur Windows uniquement.}
\end{flushright}

\subsection{Les indispensables}
Les trois logiciels indispensables sont le \texttt{Shine SDK}\footnote{SDK = Software Development Kit (trousse de développement logiciel en Français)}, le \texttt{Shine Editor}\footnote{Editeur graphique de Shine permettant d'ajouter facilement des éléments visuels dans un jeu} et \texttt{Microsoft Visual Studio 2010}.

Le \texttt{Shine Editor} et le \texttt{SDK} ne requérant pas d'installation, n'ont pas posé de problèmes dans un premier temps. En revanche, il n'a pas été facile de retrouver la version 2010 de \texttt{Visual Studio}, car aujourd'hui, Microsoft ne propose que la version \textsl{Community} de leur logiciel.
\texttt{Visual Studio} est un \texttt{IDE}\footnote{IDE = Integrated Development Environment (Environnement de Développement en Français)}. Il en existe d'autres, mais le \texttt{Shine Engine} a été développé et prévu pour être intégré à \texttt{Visual Studio}.

Même après avoir installé les outils \texttt{Shine}, il ne peuvent pas encore être exécutés indépendamment. En effet, ils requièrent le \texttt{DirectX SDK} mais aussi \texttt{Microsoft .NET Framework} (version 4.0 ou supérieur).

\subsection{Pour plus de confort}

\textit{Bien qu'ils ne soient pas réellement indispensables, les outils suivants nous été extrêmement utiles.}

Nous avons utilisé \texttt{Git}, plus précisément \texttt{Github}, l'application graphique de Git pour Windows. \href{https://fr.wikipedia.org/wiki/GitHub}{\texttt{GitHub}} est un service web d'hébergement et de gestion de développement de logiciels utilisant Git, le logiciel de gestion de versions décentralisé.

Nous avons également utilisé \texttt{Trello}, un outil de gestion de projet en ligne permettant d'assigner facilement des tâches à des utilisateurs. 

\textsc{gimp}\footnote{GNU Image Manipulation Program} est un outil d'édition et de retouche d'image. \textsc{gimp} a été utile pour créer des \texttt{sprite}\footnote{Elément graphique qui peut se déplacer sur l'écran. Dans notre cas, cet élément était une simple image en deux dimensions} simples.

En complément de \textsc{gimp} nous avons utilisé \texttt{XnView}, qui nous a permis de vérifier le formats de certains fichiers, et de convertir au bon format si besoin.

Enfin, nous avons utilisé \LaTeX\ pour la rédaction de ce rapport.

\section{Formation au \textsc{Shine Engine}}

Pour apprendre à utiliser le moteur, nous avons assisté aux formations au \texttt{Shine Engine} dispensées par \texttt{Shine Research} au Cub' à Essais, à l'incubateur d'entreprises innovantes de Franche-Comté, tous les jeudis à 17h pendant 10 semaines. Ces formations nous ont été utiles pour apprendre les bases du fonctionnement du \texttt{Shine Engine} et ainsi pouvoir maitriser par nous-même des fonctionnalités plus avancées.

\chapter{Réalisation}

Dans ce chapitre nous allons expliquer chaque élément constituant le jeu, que ce soit le joueur ou les ennemis, les armes et leurs munitions ou bien la gestion des collisions.

\section{Jeu ou Plugin ?}

Pour réaliser ce projet, notre encadrant nous a demandé de développer le jeu non pas de manière classique mais en utilisant la fonctionnalité de \texttt{plugin} du \texttt{Shine Engine}. Nous avons donc développé les mécaniques de jeu en gardant en tête que la fonction de \texttt{plugin} permettait d'utiliser le plugin simplement en l'activant lors de la création d'un niveau, par exemple en utilisant l'éditeur de Shine, ce qui nous a poussé à développer de manière générique et non pas en fonction du niveau.

Monsieur \textsc{Grosdemouge} nous a donné des \texttt{sprite} simples pour faire un niveau de test mais nous avons par la suite réalisé d'autres \texttt{sprite} pour faire d'autres niveaux afin de vérifier le bon fonctionnement du \texttt{plugin}.

\section{Éléments du plugin}
\subsection{Les personnages}

Le \texttt{plugin} doit pouvoir gérer deux types de personnages: le personnage du joueur, contrôlé par ce dernier et le ou les personnages ennemis, qui disposent de leur propre IA\footnote{\textbf{I}ntelligence \textbf{A}rtificielle}.
Pour cela nous avons crée une classe générique \texttt{Character} de laquelle héritent les classes \texttt{Player} et \texttt{Enemy}.

Cette classe a pour grande utilité de permettre un traitement générique ainsi que la possibilité d'une modification générique. Ainsi, lorsque nous avons voulu implémenter la gestion de la 3D, il nous a suffit d'ajouter un attribut à cette classe pour stocker le modèle 3D. Le joueur et les ennemis ont donc été dotés de cet attribut.

Un personnage peut posséder une arme et tirer avec celle-ci, nous détaillerons cela plus en détail dans la partie consacrée à la classe associée aux \hyperlink{armes}{\textbf{armes}}, à savoir la classe \texttt{Gun}.
Un personnage peut aussi mourir s'il entre en contact avec un projectile, exception faite des projectiles qu'il a tiré lui-même.

\subsection{Le Joueur}

Pour bien différencier le joueur des ennemis, et puisque les deux n'ont pas le même fonctionnement, nous avons crée une classe \texttt{Player} qui hérite de la classe \texttt{Character}, la rendant donc similaire à la classe \texttt{Enemy} mais dénué d'IA et contrôlé à l'aide des touches du clavier.

Le joueur peut ainsi faire avancer son avatar avec la flèche haut ou la touche Z. Les touches flèche gauche (ou la touche Q) et flèche droite (ou la touche D) permettent d'effectuer une rotation respectivement vers la gauche ou la droite. Le joueur peut aussi reculer en utilisant la touche flèche bas (ou la touche S) mais se déplace dans ce cas à la moitié de sa vitesse.

Initialement, notre encadrant ne nous avait pas demandé de permettre au joueur de reculer mais nous avons rajouté cette fonctionnalité pour un meilleur confort de jeu après avoir fait quelques test lors de l'implémentation des projectiles et de la possibilité pour l'avatar de mourir\footnote{\textsl{Il est difficile d'esquiver les projectile si on ne peut pas revenir rapidement sur ses pas}}.

\subsection{Les Ennemis}
\hypertarget{enemis}{}
\label{labelEnemis}

La classe \texttt{Enemy} permet de représenter un ennemi auquel le joueur peut-être confronté. Le \texttt{plugin} gère une liste d'ennemis pour représenter tous les ennemis d'un niveau. La classe \texttt{Enemy} héritant de la classe \texttt{Character}, un \texttt{Enemy} est sensiblement identique au joueur mais à un fonctionnement différent : il est contrôlé par une IA.
 
L'IA ne fut pas simple à mettre au point bien qu'elle ait elle-même un fonctionnement simple : si l'ennemi ne voit pas le joueur, il reste sur place, si il le voit, il se déplace vers lui tout en tirant. L'IA est basée sur un automate à deux états, l'état \texttt{attaque} et l'état \texttt{repos}. L'état \texttt{repos} est son état par défaut et il passe en état \texttt{attaque} lorsqu'il voit le joueur.

L'ennemi possède un attribut \texttt{Target} qui représente la dernière position connue du joueur. A chaque \texttt{update} du jeu\footnote{Pour chaque image rendu du jeu, on effectue une \texttt{update}, c'est-à-dire qu'on met à jour tous les éléments qui composent le jeu (leur position, leur direction, leur état...)}, le gestionaire de collisions va vérifier si l'ennemi a une ligne de vue directe sur le joueur. Si c'est le cas, il met à jour l'attribut \texttt{Target} de l'ennemi. Ce faisant, l'ennemi va passer en état \texttt{attaque} s'il ne l'est pas déjà et va se rendre jusqu'à la position cible tout en tirant en direction de celle-ci. Si, en cours de chemin, il perd sa ligne de vue directe avec le joueur, il se rendra tout de même à sa dernière position connue, ce qui peut lui permettre de voir à nouveau le joueur. Nous avons doté les ennemis d'une vision à 360 degrés pour pouvoir repérer le joueur.

\subsection{Les Armes}
\hypertarget{armes}{}

Déjà évoquée plus haut, la classe \texttt{Gun} est la classe représentant les armes dans le \texttt{plugin}. Une arme est détenue par un personnage et possède plusieurs attributs notables.

Elle dispose d'un \textsl{nom}; d'un \textsl{chargeur} contenant des munitions (6 par défaut); une \textsl{puissance}, qui correspond à la vitesse de déplacement donnée aux balles tirées par l'arme; ainsi qu'une \textsl{cadence de tir} et son \textsl{temps de rechargement} associé. Le nom n'est actuellement pas utilisé mais pourrait servir pour d'éventuelles améliorations futures. Sa cadence de tir permet de s'assurer que le joueur ou les ennemis peuvent tirer plus ou moins vite en fonction de l'arme qu'ils possèdent. Lors du lancement du \texttt{plugin}, l'arme va créer ses munitions de départ et les stocker dans son chargeur, prêtes à être utilisées.

Une arme dispose d'une fonction \texttt{Shoot}, utilisée lors de l'appel à la fonction du même nom du personnage qui possède l'arme, et qui renvoie une munition, prête à se déplacer dans le niveau. Lors de l'appel à cet fonction, la munition ainsi préparée sera alors placée dans la liste de munitions actuellement en mouvement dans le niveau et retirée du chargeur de l'arme, empêchant sa réutilisation avant qu'elle n'ait rencontré un obstacle.

\subsection{Les Munitions}

La classe \texttt{Ammo} permet de représenter les munitions. Ces munitions possèdent divers attributs: une \textsl{position}, correspondant à leur position dans le niveau; une \textsl{direction}, correspondant au sens dans lequel elles se déplacent; une \textsl{vitesse}, qui correspond à leur vitesse de déplacement; un \textsl{sprite}, si le niveau est en 2D; un \textsl{modèle}, si le niveau est en 3D; un booléen \textsl{Moving} qui permet de savoir si elle sont en cours de déplacement ou pas; une \textsl{origine}, qui désigne quel personnage a tiré la munition; et un booléen qui indique si la munition est en \textsl{3D} ou pas.

La position et la direction de la munition sont données à celle-ci lorsqu'elle est tirée par le joueur, ladite munition apparait au bout du \texttt{sprite} du joueur et se dirige dans la direction où il regarde au moment où il a tiré, puis se déplace normalement, indépendamment du joueur. La vitesse est donnée par l'arme au moment du tir. Le booléen \texttt{Moving} permet de savoir si la munition a rencontré un obstacle et donc si elle peut être remise dans le chargeur. L'origine de la munition est le personnage qui a tiré celle-ci, cela permet au personnage de ne pas se faire tuer par son propre projectile.

\subsection{La Caméra}

La classe \texttt{Camera} est la classe permettant de gérer la caméra du jeu et donc la vue que peut avoir le joueur sur le niveau.

Cette classe fut plutôt simple à faire grâce au \texttt{Shine Engine} qui dispose déjà d'une classe permettant de gérer une caméra. Notre caméra se contente d'encapsuler celle du \texttt{Shine Engine} en créant toutefois quelques fonctions qui permettent un positionnement simple de ladite caméra pour correspondre à l'utilité dont peut en faire un TPS.

La caméra a 3 modes: un mode \textsl{vue de dessus}, qui suit le joueur quand il se déplace tout en permettant d'avoir une bonne vision de ce qui se trouve autour de lui, pratique pour les niveaux en 2D; un \textsl{mode de vue TPS}, qui se place derrière le joueur; et un \textsl{mode de vue haute}, qui est proche de la vue du dessus mais dans lequel le joueur reste immobile et c'est le monde qui défile par rapport à lui. On peut passer d'un mode à l'autre grâce à la touche C. Il y a aussi possibilité d'augmenter ou de diminuer le champs de vision\footnote{En anglais : \textbf{FOV} : \textbf{F}ield \textbf{O}f \textbf{V}iew} lorsqu'on est en mode caméra TPS avec les touches + et - .

\subsection{Le Gestionnaire de collisions}
\hypertarget{gest_coll}{}

Le gestionnaire de collisions est représenté grâce à la classe \texttt{CollisionsManager}. C'est cette classe qui va gérer toutes les collisions du \texttt{plugin}, que ce soit les personnages et les munitions, les munitions et les murs ou bien le champs de vision de ennemis.

La classe possède deux attributs: une liste de \texttt{CollisionShape} et le nombre de \texttt{CollisionShape} contenus dans cette liste. Une explication des \texttt{CollisionsShape} et de la gestion des collisions dans le \texttt{plugin} est donnée dans la \hyperlink{gest_coll}{\textbf{prochaine partie}}, consacrée à la gestion des collisions.


\pagebreak
\section{Mécaniques de jeu}

Dans cette partie nous allons expliquer le fonctionnement de la gestion des collisions dans le \texttt{plugin} ainsi que le fonctionnement des mécaniques de jeu du \texttt{plugin}.

\subsection{Gestion des collisions}

La partie de gestion des collisions nous fut grandement simplifiée grâce au \texttt{Shine Engine} et notamment grâce à 3 fonctionnalités de celui-ci:

\begin{itemize}  


\item Les \texttt{CollisionShape}: il s'agit de sortes de segments qui servent dans le moteur notamment pour faire office de murs physiques. Ils peuvent également être placés directement depuis l'éditeur, ce qui en fait un outil très pratique pour les collisions avec le décor.

\item Le \texttt{Character Controller}: il s'agit d'une classe qui intègre nativement les collisions entre elle et les \texttt{CollisionShape} ainsi qu'entre les différentes instances de la classe, empêchant ainsi un \texttt{Character Controller} de passer à travers un autre \texttt{Character Controller} ou à travers un \texttt{CollisionShape}.

\item La fonction \texttt{Intersect} pour les entités 2D: il s'agit d'une fonction qui permet de savoir si deux entités 2D, c'est-à-dire des \texttt{sprite}, se croisent.

\end{itemize}

Grâce à ces 3 éléments, peu de travail sur les collisions restaient à faire. Nous avons doté la classe \texttt{Character} d'un attribut de type \texttt{Character Controller} et à partir de là, aucun personnage ne pouvait passer à travers un mur (représenté par un \texttt{CollisionShape}), ou à travers un autre personnage. Pour gérer la collision entre les munitions se déplaçant dans le monde et un personnage, la fonction \texttt{Intersect} est utilisée pour voir si les deux \texttt{sprite} se touchent ou se croisent.


Il nous restait donc à gérer les collisions entre les munitions et les \texttt{CollisionShape} ainsi que les lignes de vue des ennemis.

De ce fait pour gérer ces collisions le gestionnaire de collisions procède ainsi: 

\begin{itemize}
\item Pour les munitions et les \texttt{CollisionShape}, il vérifie si il y a intersection entre le \texttt{CollisionShape} et la trajectoire de la balle entre sa position actuelle et sa position après déplacement.

\item Pour les lignes de vue entre les ennemis et le joueur, pour chaque ennemi, le gestionnaire vérifie si il y a un \texttt{CollisionShape} (un mur) entre le joueur et l'ennemi. Si ce n'est pas le cas alors l'ennemi a une ligne de vue directe sur le joueur et peut donc passer en état \texttt{attaque}.\footnote{Pour plus de détails concernant le comportement des ennemis, reportez-vous à la \hyperlink{enemis}{\textbf{section correspondante}} (page \pageref{labelEnemis})}

\end{itemize}

\pagebreak

Pour les collisions en 3D, et par souci de simplicité pour le développement du projet, le gestionnaire va utiliser les \texttt{sprite} 2D associés à chaque élément. Pour comprendre comment il peut faire cela, intéressons-nous à la prochaine partie, consacrée au fonctionnement du \texttt{plugin}.

\subsection{Fonctionnement du \texttt{plugin}}

Maintenant que nous avons vu les divers éléments constituant le \texttt{plugin} ainsi que la gestion des collisions, nous pouvons nous intéresser au fonctionnement du \texttt{plugin}.

Le \texttt{plugin} fonctionne en deux temps. Tout d'abord lors de l'appel à la fonction \texttt{OnPlayStart} du \texttt{Shine Engine}, puis lors de l'appel à la fonction \texttt{OnPostUpdate} du moteur de jeu. De plus le \texttt{plugin} est conçu pour fonctionner avec des niveaux en 2D ou bien en 3D.

La fonction \texttt{OnPlayStart} est appelée lorsque un niveau est débuté. Dans l'éditeur cela correspond aussi à l'appui sur le bouton \texttt{Play}, qui sert à tester le niveau créé avec l'aide de l'éditeur.

Lors de l'appel à la fonction \texttt{OnPlayStart}, le \texttt{plugin} va initialiser tout ce qu'il peut en fonction du niveau, il va donc initialiser le joueur en fonction de la position du \texttt{sprite} ou du modèle de celui-ci, en sachant qu'il faut respecter une convention de nommage propre du nom donné au joueur dans l'éditeur pour que le \texttt{plugin} puisse le trouver. Puis le \texttt{plugin} va créer et initialiser autant d'ennemis qu'il trouve de \texttt{sprite} ou de modèles respectant la convention de nommage.

Il est à noter que si le \texttt{plugin} trouve des modèles 3D, il va charger des \texttt{sprite} 2D depuis la bibliothèque et créer les entités 2D associées afin de pouvoir gérer les collisions. Ce fonctionnement pourrait poser problème pour un vrai jeu 3D mais nous avons conçu le \texttt{plugin} comme cela pour le projet pour un souci de simplicité.

La fonction \texttt{OnPostUpdate} est appelée par le moteur de jeu après sa propre \texttt{update}. C'est dans cette fonction que le \texttt{plugin} se met à jour.

A chaque appel à la fonction \texttt{OnPostUpdate}, le \texttt{plugin} se met à jour. Il va d'abord vérifier l'appui sur les différents inputs du joueur pour faire réagir l'avatar de celui-ci ou la caméra en conséquence. Il va ensuite faire appel au gestionnaire de collisions pour s'occuper des lignes de vue de chaque ennemi ainsi que les éventuels tirs de ceux-ci; puis il va, toujours en faisant appel au gestionnaire de collisions, vérifier les collisions des munitions avec les différents éléments de l'environnement, personnages inclus; enfin il appelle succinctement les différentes fonctions \texttt{update} des différents éléments du niveau (\textsl{joueur}, \textsl{ennemis} et \textsl{munitions}).


\section{Problèmes rencontrés}

\subsection{Problèmes logiciels}

Nous l'avons mentionné dans la partie \hyperlink{installation}{\textbf{Installation}} (page~\pageref{labelInstal}), trouver la version complète de \texttt{Microsoft Visual Studio 2010} n'a pas été tâche facile. En effet, le lien n'est plus disponible sur le site de Microsoft et la plupart des téléchargements proposés par d'autres sites renvoyaient sur le lien, désormais inactif, se trouvant sur le site de Microsoft. Nous avons toutefois fini par trouvé un exemple fonctionnel.

De plus, nous n'avions jamais développé sous Windows en utilisant \texttt{Visual Studio}, notre formation à la fac ne nous préparant à développer que sous des systèmes Linux, nous avons eu besoin d'un temps d'adaptation.

\subsection{Problèmes de documentation}

Le plus gros problème que nous avons rencontré durant le projet est la documentation inexistante du \texttt{Shine Engine}. En effet, celui-ci étant encore relativement "jeune", il n'existe pas encore de documentation ou de tutoriel ni même d'aide sur internet y correspondant. La seule aide que nous pouvions obtenir venait de \texttt{Shine Research}, mais nous ne pouvions passer notre temps à leur demander de l'aide. Nous avons donc dû observer en détail la plupart des \texttt{headers}\footnote{Entêtes contenant les définitions d'un fichier C++} du \texttt{SDK}, afin de voir les fonctions disponibles pour les classes que nous utilisions, et de se baser sur le nom des fonctions et des paramètres pour deviner ce qu'elles faisaient.

Heureusement, et cela prouve, si c'était encore nécessaire, que le \texttt{Shine Engine} est bien conçu, les fonctions du moteur font exactement ce à quoi on peut s'attendre en fonction de leur nom. Grâce à cela, et avec un peu de persévérance, nous avons pu surmonter ce problème et apprendre à utiliser pleinement le \texttt{Shine Engine}. 

\chapter{Bilan}

Le délai imparti pour le projet arrive à son terme, il est donc nécessaire d'en dresser un bilan et de conclure.

Le sujet du projet semblait modeste de prime abord, pourtant, au fur et à mesure de son développement, nous avons pu constater que développer un tel projet n'était pas simple, même avec un outil performant, tel que le \texttt{Shine Engine}.

Nous avons eu besoin d'un temps d'adaptation à \texttt{Visual Studio 2010} et au \texttt{Shine Engine}, mais à mesure que le projet avançait et que nous améliorions notre maitrise de ces deux outils, de nouvelles perspectives s'ouvraient à nous, pour perfectionner de plus en plus le \texttt{plugin}.

Ainsi, nous pourrions envisager d'apporter des améliorations au \texttt{plugin}, par exemple en dotant les ennemis d'un cône de vision plutôt que d'une vision à 360°. Cela pourrait nous permettre au joueur de s'approcher discrètement des ennemis et donc par la suite pousser à l'instauration d'une mécanique de furtivité. Nous pourrions aussi ajouter divers armes pouvant être ramassées par le joueur ou même des améliorations spécifiques à une arme. La gestion des collisions 3D avec une hitbox\footnote{Masque de Collision en Français : zone d'un élément graphique sensible d'être touchée par un projectile} 3D pourrait être possible tout comme l'implémentation d'une minimap\footnote{Carte miniature} qui nous avait été demandée mais que nous n'avons pu implémenter par manque de temps.

Le \texttt{plugin} produit lors de se projet est lui-même un outil qui peut se révéler utile pour la création d'un TPS car il peut être réutilisable aisément voire combinable avec d'autres \texttt{plugins}.

En ce qui nous concerne, nous avons appris à utiliser un moteur de jeu, nous ouvrant la porte au développement amateur de jeux plus complet que ceux dont nous étions capables auparavant. Nous avons aussi amélioré nos compétences en C++, qui est un des langages les plus utilisés actuellement. Enfin, nous avons pu en apprendre plus sur le développement d'un jeu vidéo, encadrés par des professionnels d'expérience que sont Monsieur \textsc{Grosdemouge} et ses employés. C'est une bonne expérience que d'avoir pu développer ce projet et nous sommes heureux d'avoir pu le faire.

\printglossaries

\end{document}