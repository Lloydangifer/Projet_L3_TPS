\documentclass[12pt]{report}


\usepackage[latin1]{inputenc} % un package
\usepackage[T1]{fontenc}      % un second package
\usepackage[francais]{babel}  % un troisième package
\usepackage{lipsum}
\usepackage{aeguill} % Police moins floue
\usepackage{graphicx} % Insérer des images 

\usepackage{titling} % image on title page

\usepackage{xcolor} % DES JOLIES COULEURS

\usepackage{listings} % pour écrire du code avec de la coloration syntaxique
%%configuration de listings
\lstset{
language=python,
basicstyle=\ttfamily\small, %
identifierstyle=\color{black}, %
keywordstyle=\color{blue}, %
stringstyle=\color{purple}, %
commentstyle=\it\color{green}, %
columns=flexible, %
tabsize=2, %
extendedchars=true, %
showspaces=false, %
showstringspaces=false, %
numbers=left, %
numberstyle=\tiny, %
breaklines=true, %
breakautoindent=true, %
captionpos=b
}


\usepackage{hyperref} % Créer des liens et des signets, utile pour la table des matières
\hypersetup{	
	colorlinks=true, %colorise les liens 
	breaklinks=true, %permet le retour à la ligne dans les liens trop longs 
	urlcolor= blue, %couleur des hyperliens 
	linkcolor= black,	%couleur des liens internes 
	citecolor=black,	%couleur des références 
	pdftitle={Rapport de projet}, %informations apparaissant dans 
	pdfauthor={Virgil Manrique, Quentin Guillien}, %les informations du document 
	pdfsubject={TPS avec le Shine Engine}	%sous Acrobat. 
} 

\usepackage[margin=3cm]{geometry}

\usepackage{titlesec}
\titleformat{\chapter}[hang]{\bf\huge}{\thechapter}{2pc}{}
\titlespacing*{\chapter}{0pt}{0pt}{40pt}

%Glossaire
\usepackage{glossaries}
\makeglossaries
\newacronym{TPS}{TPS}{Third-Person Shooter}

\begin{document}


\begin{titlepage}
	\centering
	\includegraphics[width=4.5cm]{logo-ufc.jpg}\par\vspace{2mm}
	{\scshape\large Université de Franche-Comté \par}
	\vspace{1cm}
	{\scshape\Large Rapport de projet tuteuré\par
	Licence informatique 3\up{ème} Année\par}
	\vspace{1.5cm}
	{\huge\bfseries Création d'un Third-Person Shooter avec le \textsc{Shine Engine}\par}
	\vspace{9mm}
	\includegraphics[width=6cm]{logo_shine.png}\par\vspace{15mm}
	{\Large Virgil \textsc{Manrique} \hspace{5mm} Quentin \textsc{Guillien}\par}
	\vfill
	Encadrant : \par
	Sylvain \textsc{Grosdemouge}

	\vfill

% Bottom of the page
	{\large Année 2015-2016\par}
\end{titlepage}


\setlength{\parskip}{2.5mm}

\section*{\centering Remerciements}
\phantomsection
%\addcontentsline
\vspace{1cm}

Ce projet tuteuré n'aurait pu être réalisé sans l'aide de plusieurs personnes que nous tenons à remercier.
\vspace{4mm}

Tout d'abord, nous remercions notre encadrant M. Sylvain \textsc{Grosdemouge} pour nous avoir guidé et prodigué ses conseils durant la réalisation de ce projet.

Ensuite, nous voulons remercier M. Bastien \bsc{Schatt}, pour nous avoir aidés lors de notre apprentissage de l'utilisation du Shine Engine ainsi que pour sa réactivité lorsque nous avons rencontré des problèmes.

Nous voulons également remercier M. Nicolas \bsc{Diot}, pour son assistance apportée par rapport au fonctionnement de l'éditeur de niveaux du Shine Engine et des ressources graphiques.

Nous tenons enfin à remercier toutes les personnes qui nous ont aidés de près ou de loin.


% Table des matières, sans numérotation
\renewcommand{\thepage}{}
\tableofcontents
\newpage
\renewcommand{\thepage}{\arabic{page}}


% Introduction
\chapter{Cadre du projet}
Dans le cadre de notre 3\up{ème} année de licence informatique à l'université de Franche-Comté, il nous a été demandé de réaliser un projet dans le cadre du module projet tuteuré. La durée du projet s'étendait d'Octobre à Mars.

Parmis les sujets proposés, l'un d'entre eux a particulièrement retenu notre attention. Il s'agissait du développement d'un Third-Person Shooter en utilisant un moteur de jeu : le \texttt{Shine Engine} développé par M. Sylvain \textsc{Grosdemouge}.

Nous avons pu nous voir attribuer ce sujet l'ayant placé en première position dans notre liste de choix.

Pour comprendre l'intérêt que nous portions à ce sujet, il faut nous pencher sur les différents éléments qui le constituent, à savoir les Third-Person Shooter, les moteurs de jeu, et le \texttt{Shine Engine}.

\section{Les Third-Person Shooter}

Un TPS (Third-Person Shooter ou jeu de tir à la troisième personne en français) est un sous-genre des jeux de tir et donc des jeux d'action. Les jeux de tir mettent souvent la rapidité et la réactivité du joueur à l'épreuve. L'objectif de ce genre de jeu est de vaincre ses ennemis en utilisant une arme de tir. La particularité des \texttt{TPS}\footnote{\textbf{T}hird-\textbf{P}erson \textbf{S}hooter} est que le joueur voit son personnage de manière externe contrairement aux \texttt{FPS}\footnote{\textbf{F}irst-\textbf{P}erson \textbf{S}hooter : Jeu de tir à la 1\up{ère} personne} où le joueur voit à travers les yeux de son personnage.

\begin{figure}[!h] %on ouvre l'environnement figure
\centering
\includegraphics[width=7cm]{re4_1.jpg} %ou image.png, .jpeg etc.
\caption{Un exemple de \texttt{TPS} : Resident Evil 4} %la légende
\label{re4} %l'étiquette pour faire référence à cette image
\end{figure} %on ferme l'environnement figure

\section{Les moteurs de jeu}

``Un moteur de jeu est un ensemble de composants logiciels qui effectuent des calculs de géométrie et de physique utilisés dans les jeux vidéo. L'ensemble forme un simulateur en temps réel souple qui reproduit les caractéristiques des mondes imaginaires dans lesquels se déroulent les jeux. Le but visé par un moteur de jeu est de permettre à une équipe de développement de se concentrer sur le contenu et le déroulement du jeu plutôt que la résolution de problèmes informatiques.''
\begin{flushright}
-- \href{https://fr.wikipedia.org/wiki/Moteur_de_jeu}{\textsl{Définition Wikipédia}}
\end{flushright}

\section{Le \texttt{Shine Engine}}

Le \texttt{Shine Engine} est un moteur de jeu créé par notre encadrant, Monsieur Sylvain \textsc{Grosdemouge}. Monsieur \textsc{Grosdemouge} a commencé le développement du \texttt{Shine Engine} en 2005 et en 2012 est sorti \textsc{R.A.W.}(Realm Of Ancient War), premier jeu développé en utilisant le \texttt{Shine Engine}. Ce moteur de jeu est développé en C++ et permet de faire du développement multi-plateforme. Il permet aussi de gérer facilement la 3D ce qui permet de s'affranchir de beaucoup de limites pour le développement d'un jeu.

\section{Le Projet}

Les trois éléments cités précédemment rendaient pour nous le projet attrayant: les TPS sont un genre de jeu au concept simple mais distrayant; utiliser un moteur de jeu permet de se concentrer sur les mécaniques de jeu, qui sont pour nous la partie la plus intéressante du développement d'un jeu; et enfin, le \texttt{Shine Engine}, un moteur qui a fait ses preuves, qui est efficace et qui nous permet de développer en C++, le langage que nous préférons.

\begin{figure}[!h] %on ouvre l'environnement figure
\centering
\includegraphics[width=6cm]{raw-03.jpg} %ou image.png, .jpeg etc.
\caption{ \textsc{Realm Of Ancient War}} %la légende
\label{re4} %l'étiquette pour faire référence à cette image
\end{figure} %on ferme l'environnement figure

\chapter{Préparation}

\section{Installation des outils}
\hypertarget{installation}{}

\label{labelInstal}Avant de commencer à coder, il a d'abord fallu installer plusieurs outils logiciels.

\begin{flushright}
\textit{Tous les outils mentionnés ont été utilisés, dans notre cas, sur Windows uniquement.}
\end{flushright}

\subsection{Les indispensables}
Les trois logiciels indispensables sont le \texttt{Shine SDK}\footnote{SDK = Software Development Kit (trousse de développement logiciel en Français)}, le \texttt{Shine Editor}\footnote{Editeur graphique de Shine permettant d'ajouter facilement des éléments visuels dans un jeu} et \texttt{Microsoft Visual Studio 2010}.

Le \texttt{Shine Editor} et le \texttt{SDK} ne requérant pas d'installation, n'ont pas posé de problèmes dans un premier temps. En revanche, il n'a pas été facile de retrouver la version 2010 de \texttt{Visual Studio}, car aujourd'hui, Microsoft ne propose que la version \textsl{Community} de leur logiciel.
\texttt{Visual Studio} est un \texttt{IDE}\footnote{IDE = Integrated Development Environment (Environnement de Développement en Français)}. Il en existe d'autres, mais le \texttt{Shine Engine} a été développé et prévu pour être intégré à \texttt{Visual Studio}.

Même après avoir installé les outils \texttt{Shine}, il ne peuvent pas encore être exécutés indépendamment. En effet, ils requièrent le \texttt{DirectX SDK} mais aussi \texttt{Microsoft .NET Framework} (version 4.0 ou supérieur).

\subsection{Pour plus de confort}

\textit{Bien qu'ils ne soient pas réellement indispensables, les outils suivants nous été extrêmement utiles.}

Nous avons utilisé \texttt{Git}, plus précisément \texttt{Github}, l'application graphique de Git pour Windows. \href{https://fr.wikipedia.org/wiki/GitHub}{\texttt{GitHub}} est un service web d'hébergement et de gestion de développement de logiciels utilisant Git, le logiciel de gestion de versions décentralisé.

Nous avons également utilisé \texttt{Trello}, un outil de gestion de projet en ligne permettant d'assigner facilement des tâches à des utilisateurs. 

\textsc{gimp}\footnote{GNU Image Manipulation Program} est un outil d'édition et de retouche d'image. \textsc{gimp} a été utile pour créer des \texttt{sprite}\footnote{Elément graphique qui peut se déplacer sur l'écran. Dans notre cas, cet élément était une simple image en deux dimensions} simples.

En complément de \textsc{gimp} nous avons utilisé \texttt{XnView}, qui nous a permis de vérifier le formats de certains fichiers, et de convertir au bon format si besoin.

Enfin, nous avons utilisé \LaTeX\ pour la rédaction de ce rapport.

\section{Formation au \textsc{Shine Engine}}

Pour apprendre à utiliser le moteur, nous avons assisté aux formations au \texttt{Shine Engine} dispensées par \texttt{Shine Research} au Cub' à Essais, à l'incubateur d'entreprises innovantes de Franche-Comté, tous les jeudis à 17h pendant 10 semaines. Ces formations nous ont été utiles pour apprendre les bases du fonctionnement du \texttt{Shine Engine} et ainsi pouvoir maitriser par nous-même des fonctionnalités plus avancées.

\chapter{Réalisation}

Dans ce chapitre nous allons expliquer chaque élément constituant le jeu, que ce soit le joueur ou les ennemis, les armes et leurs munitions ou bien la gestion des collisions.

\section{Jeu ou Plugin ?}

Pour réaliser ce projet, notre encadrant nous a demandé de développer le jeu non pas de manière classique mais en utilisant la fonctionnalité de \texttt{plugin} du \texttt{Shine Engine}. Nous avons donc développé les mécaniques de jeu en gardant en tête que la fonction de \texttt{plugin} permettait d'utiliser le plugin simplement en l'activant lors de la création d'un niveau, par exemple en utilisant l'éditeur de Shine, ce qui nous a poussé à développer de manière générique et non pas en fonction du niveau.

Monsieur \textsc{Grosdemouge} nous a donné des \texttt{sprite} simples pour faire un niveau de test mais nous avons par la suite réalisé d'autres \texttt{sprite} pour faire d'autres niveaux afin de vérifier le bon fonctionnement du \texttt{plugin}.

\section{Éléments du plugin}
\subsection{Les personnages}

Le \texttt{plugin} doit pouvoir gérer deux types de personnages: le personnage du joueur, contrôlé par ce dernier et le ou les personnages ennemis, qui disposent de leur propre IA\footnote{\textbf{I}ntelligence \textbf{A}rtificielle}.
Pour cela nous avons crée une classe générique \texttt{Character} de laquelle héritent les classes \texttt{Player} et \texttt{Enemy}.

Cette classe a pour grande utilité de permettre un traitement générique ainsi que la possibilité d'une modification générique. Ainsi, lorsque nous avons voulu implémenter la gestion de la 3D, il nous a suffit d'ajouter un attribut à cette classe pour stocker le modèle 3D. Le joueur et les ennemis ont donc été dotés de cet attribut.

Un personnage peut posséder une arme et tirer avec celle-ci, nous détaillerons cela plus en détail dans la partie consacrée à la classe associée aux \hyperlink{armes}{\textbf{armes}}, à savoir la classe \texttt{Gun}.
Un personnage peut aussi mourir s'il entre en contact avec un projectile, exception faite des projectiles qu'il a tiré lui-même.

\subsection{Le Joueur}

Pour bien différencier le joueur des ennemis, et puisque les deux n'ont pas le même fonctionnement, nous avons crée une classe \texttt{Player} qui hérite de la classe \texttt{Character}, la rendant donc similaire à la classe \texttt{Enemy} mais dénué d'IA et contrôlé à l'aide des touches du clavier.

Le joueur peut ainsi faire avancer son avatar avec la flèche haut ou la touche Z. Les touches flèche gauche (ou la touche Q) et flèche droite (ou la touche D) permettent d'effectuer une rotation respectivement vers la gauche ou la droite. Le joueur peut aussi reculer en utilisant la touche flèche bas (ou la touche S) mais se déplace dans ce cas à la moitié de sa vitesse.

Initialement, notre encadrant ne nous avait pas demandé de permettre au joueur de reculer mais nous avons rajouté cette fonctionnalité pour un meilleur confort de jeu après avoir fait quelques test lors de l'implémentation des projectiles et de la possibilité pour l'avatar de mourir\footnote{\textsl{Il est difficile d'esquiver les projectile si on ne peut pas revenir rapidement sur ses pas}}.

\subsection{Les Ennemis}

La classe \texttt{Enemy} permet de représenter un ennemi auquel le joueur peut-être confronté. Le \texttt{plugin} gère une liste d'ennemis pour représenter tous les ennemis d'un niveau. La classe \texttt{Enemy} héritant de la classe \texttt{Character}, un \texttt{Enemy} est sensiblement identique au joueur mais à un fonctionnement différent : il est contrôlé par une IA.
 
L'IA ne fut pas simple à mettre au point bien qu'elle ait elle-même un fonctionnement simple : si l'ennemi ne voit pas le joueur, il reste sur place, si il le voit, il se déplace vers lui tout en tirant. L'IA est basée sur un automate à deux états, l'état \texttt{attaque} et l'état \texttt{repos}. L'état \texttt{repos} est son état par défaut et il passe en état \texttt{attaque} lorsqu'il voit le joueur.

L'ennemi possède un attribut \texttt{Target} qui représente la dernière position connue du joueur. A chaque \texttt{update} du jeu\footnote{Pour chaque image rendu du jeu, on effectue une \texttt{update}, c'est-à-dire qu'on met à jour tous les éléments qui composent le jeu (leur position, leur direction, leur état...)}, le gestionaire de collisions va vérifier si l'ennemi a une ligne de vue directe sur le joueur. Si c'est le cas, il met à jour l'attribut \texttt{Target} de l'ennemi. Ce faisant, l'ennemi va passer en état \texttt{attaque} s'il ne l'est pas déjà et va se rendre jusqu'à la position cible tout en tirant en direction de celle-ci. Si, en cours de chemin, il perd sa ligne de vue directe avec le joueur, il se rendra tout de même à sa dernière position connue, ce qui peut lui permettre de voir à nouveau le joueur. Nous avons doté les ennemis d'une vision à 360 degrés pour pouvoir repérer le joueur.

\subsection{Les Armes}
\hypertarget{armes}{}

Déjà évoquée plus haut, la classe Gun est la classe représentant les armes dans le plugin. Une arme est détenue par un personnage et possède plusieurs attributs notables.

 Elle dispose d'un nom; d'un chargeur contenant des munitions (6 par défaut); une puissance, qui correspond à la vitesse de déplacement donnée aux balles tirées par l'arme; ainsi qu'une cadence de tir et son temps de rechargement associé. Le nom n'est actuellement pas utilisé mais pourrait servir pour d'éventuellement améliorations futures. Sa cadence de tir permet de s'assurer que le joueur ou les ennemis peuvent tirer plus ou moins vite en fonction de l'arme qu'ils possèdent. Lors du lancement du plugin, l'arme va créer ses munitions de départ et les stocker dans son chargeur, prêtes à être utilisées.

Une arme dispose d'une fonction Shoot, utilisée lors de l'appel à la fonction du même nom du personnage qui possède l'arme, et qui renvoie une munition, prête à se déplacer dans le niveau. Lors de l'appel à cet fonction, la munition ainsi préparée sera alors placée dans la liste de munitions actuellement en mouvement dans le niveau et retirée du chargeur de l'arme, empêchant sa réutilisation avant qu'elle n'ait rencontré un obstacle.

\subsection{Les Munitions}

La classe Ammo permet de représenter les munitions. Ces munitions possèdent divers attributs: une position, correspondant à leur position dans le niveau; une direction, correspondant au sens dans lequel elle se déplacent; une vitesse, qui correspond à leur vitesse de déplacement; un sprite, si le niveau est en 2D; un modèle, si le niveau est en 3D; un booléen Moving qui permet de savoir si elle sont en cours de déplacement ou pas; une origine, qui désigne quel personnage a tiré la munition; et un booléen qui indique si la munition est en 3D ou pas.

La position et la direction de la munition sont données à celle-ci lorsqu'elle est tirée par le joueur, ladite munition apparait au bout du sprite du joueur et se dirige dans la direction où il regarde au moment où il a tiré, puis se déplace normalement, indépendamment du joueur. La vitesse est donnée par l'arme au moment du tir. Le booléen Moving permet de savoir si la munition a rencontré un obstacle et donc si elle peut être remise dans le chargeur. L'origine de la munition est le personnage qui a tiré celle-ci, cela permet au personnage de ne pas se faire tuer par son propre projectile.

\subsection{La Caméra}

La classe Camera est la classe permettant de gérer la caméra du jeu et donc la vue que peut avoir le joueur sur le niveau.

Cette classe fut plutôt simple à faire grâce au Shine Engine qui dispose déjà d'une classe permettant de gérer une caméra. Notre caméra se contente d'encapsuler celle du Shine Engine en créant toutefois quelques fonctions qui permettent un positionnement simple de ladite caméra pour correspondre à l'utilité dont peut en faire un TPS.

La caméra à 3 modes: un mode vue de dessus, qui suit le joueur quand il se déplace tout en permettant d'avoir une bonne vision de ce qui se trouve autour de lui, pratique pour les niveaux en 2D; un mode de vue TPS, qui se place derrière le joueur; et un mode de vue haute, qui est proche de la vue du dessus mais dans lequel le joueur reste immobile et c'est le monde qui défile par rapport à lui. On peut passer d'un mode à l'autre grâce à la touche C. Il y a aussi possibilité d'augmenter ou de diminuer le Fov lorsqu'on est en mode caméra TPS avec les touches + et - .

\subsection{Le Gestionnaire de collisions}

Le gestionnaire de collisions est représenté grâce à la classe CollisionManager. C'est cette classe qui va gérer toutes les collisions du plugin, que ce soit les personnages et les munitions, les munitions et les murs ou bien le champs de vision de ennemis.

La classe possède deux attributs: une liste de CollisionShape et le nombre de CollisionShape contenus dans cette liste. Une explication des CollisionsShape et de la gestion des collisions dans le plugin est donnée dans la prochaine partie, consacrée à la gestion des collisions.

\section{Mécaniques de jeu}
\subsection{Gestion des collisions}

\section{Problèmes rencontrés}

\subsection{Problèmes logiciels}

Nous l'avons mentionné dans la partie \hyperlink{installation}{\textbf{Installation}} (page~\pageref{labelInstal}), trouver la version complète de \texttt{Microsoft Visual Studio 2010} n'a pas été tâche facile.

Cependant, cela n'a pas été le plus important des problèmes logiciel que nous avons eu. En effet, il nous est arrivé par exemple de ne plus pouvoir lancer l'éditeur de \texttt{Shine} alors qu'il marchait auparavant, sans savoir pourquoi. Réinstaller l'éditeur, ou installer une version plus récente résolvait en général les problèmes rencontrés. Il nous est également arrivé de simplement ne pas du tout pouvoir faire fonctionner le \texttt{Shine Editor} sur un PC (la seule option était ici d'utiliser un autre PC).

\subsection{Problèmes de code}

Le problème majeur qui nous a couté le plus de temps est celui-ci : 

\begin{lstlisting}
	///	@todo comment
\end{lstlisting}

Cette ligne, combinée à l'inexistence de documentation, nous a souvent laissé dans le flou quand à la manière de procéder pour effectuer des tâches parfois assez simples.
La seule chose dont on pouvait s'aider était les fichiers d'entête dans les dossier du \texttt{Shine SDK} : en lisant les définitions des méthodes et les noms des paramètres, on pouvait au mieux \textsl{deviner} la façon d'utiliser ces méthodes.

Bien sûr, quand on ne pouvait plus avancer, nous avons pris contact avec l'équipe de \texttt{Shine}. Cependant, la réponse n'étant évidemment pas immédiate, il nous est arrivé de rester bloquer des après-midis entiers à essayer de faire marcher un bout de code.



\chapter{Bilan}

\subsection{Optimisations Possibles}

Ennemis avec cône de vision
Améliorations d'armes liés au nom de l'arme

\printglossaries

\end{document}